---
title: "7章"
free: false
---

# 7章
## オブジェクト指向

Rustはオブジェクト指向プログラミング言語ではない
 - Rustは、データと関数の継承機能を意図的に持っていません。
でも多くのプログラミング機能を持つので、オブジェクト指向の様なことができる

### オブジェクト指向の簡単なおさらい

- **カプセル化**
  - データと関数を オブジェクト という一つの型の概念的な単位で関連付けること。
- **抽象化**
   - データや関数のメンバを隠して、オブジェクトの実装の詳細を難読化すること。
- **ポリモーフィズム**
   - 1つのインターフェースを通して、異なるタイプのオブジェクトと相互作用する能力のこと。
- **継承**
  - 他のオブジェクトからデータや振る舞いを引き継ぐこと。


### メソッドでカプセル化をする
- `impl`でメソッドを定義
  - 定義しているメソッドの引数で自分自身を参照させる
  - `&self`ならインスタンスへの不変参照、`&mut self`でインスタンスの可変参照
  - `&str`でフィールドを返すしているので所有権は移さずに値を扱うことができる　 　 

```Rust
struct SeaCreature {
    noise: String,
}

impl SeaCreature {
    fn get_sound(&self) -> &str {
        &self.noise
    }
}

fn main() {
    let creature = SeaCreature {
        noise: String::from("blub"),
    };
    println!("{}", creature.get_sound());
}
```

Rustでは基本的にフィールドやメソッドにはデフォルトでプライベートである。
これによって構造体のカプセル化が担保されている
公開したい時はメソッドやフィールドに`pub`就職子をつける

```Rust
struct SeaCreature {
    pub name: String,
    noise: String,
}

impl SeaCreature {
    pub fn get_sound(&self) -> &str {
        &self.noise
    }
}

fn main() {
    let creature = SeaCreature {
        name: String::from("Ferris"),
        noise: String::from("blub"),
    };
    println!("{}", creature.get_sound());
}
```

下記はNG、基本的に内部(`impl`で定義したメソッド)からしか呼び出せない
```Rust
println!("{}", creature.noise);
```

### トレイトを用いたポリモーフィズム
- Rustはポリモーフィズムをトレイトを用いて表現する
トレイトを使って構造体にメソッド群を関連づける

トレイト内のメソッドのシグネチャを定義

```Rust
trait MyTrait {
    fn foo(&self);
    ...
}
```

構造体がトレイトを実装
これでfooメソッドをMyStructが使えるように
```Rust
impl MyTrait for MyStruct { 
    fn foo(&self) {
    }
```

トレイトを使うことで、以下のような柔軟な設計が可能になる。
引数にトレイトを持つ構造体ならなんでも取れる
```Rust
fn make_anything_noisy<T: NoiseMaker>(thing: T) {
    thing.make_noise();
}
```

トレイトには実装を定義したメソッドを持つこともできる。
これによって様々な構造体で同じ動作を共有できる。
```Rust
trait NoiseMaker {
    fn make_noise(&self);
    
    fn make_alot_of_noise(&self){
        self.make_noise();
        self.make_noise();
        self.make_noise();
    }
}
```

トレイトは他のトレイトからメソッドを継承できる
- コードの再利用や機能の階層化・段階的な設計が可能に
```Rust
trait NoiseMaker {
    fn make_noise(&self);
}

trait LoudNoiseMaker: NoiseMaker {
    fn make_alot_of_noise(&self) {
        self.make_noise();
        self.make_noise();
        self.make_noise();
    }
}

```

## 動的ディスパッチ静的ディスパッチ
メソッドは上記の二つの方法で実行される

**ディスパッチ**
- 「どの関数（メソッド）を実行するか決めること」です。
&nbsp;
**静的ディスパッチ**
  - コンパイル時にどの関数を実行するかが確定
    - 実行が早い

```Rust
struct Dog;

impl NoiseMaker for Dog {
    fn make_noise(&self) {
        println!("ワン！");
    }
}

fn main() {
    let dog = Dog;
    do_noise(dog);
}

fn do_noise_dog(animal: Dog) {
    animal.make_noise(); // ← Dog の make_noise を呼ぶ
}
```
`do_noise`の引数を型指定してのでコンパイル時にどの関数を実行するか(どのインスタンスがメソッドを使うか)が確定しているから処理が早い
- 基本的にRustでは静的ディスパッチを使って最適化するべき
&nbsp;
**動的ディスパッチ**
  - インスタンスタイプが不明な場合。正しい関数を呼び出す方法を見つけなければならない。
  - `&dyn` を修飾子として使うことで動的ディスパッチとなる
  - 速度は遅くなるがより柔軟性が上がる
  - 型に縛られず、「共通インターフェースで扱える」。
  - 異なる型を1つのコレクションにまとめられる。
 ```Rust
fn do_noise(animal: &dyn NoiseMaker) {
    animal.make_noise(); // 動的ディスパッチ
}
```

動的ディスパッチを使うと、後から新しい型を追加しても、既存のコードを変えずに動く。
- ユーザーが独自の型を実装しても、play_sound() に渡せる。
→ オープン／クローズド原則（拡張には開かれ、修正には閉じている）を守れる。

```Rust
pub fn play_sound(thing: &dyn NoiseMaker) {
    thing.make_noise();
}
```

### トレイトオブジェクト
オブジェクトのインスタンスを `&dyn MyTrait` 型のパラメータに渡すとき(**動的ディスパッチ**)、 **トレイトオブジェクト** と呼ばれるものを渡す。

インスタンスの正しいメソッドを間接的に呼び出すことを可能にするのがトレイトオブジェクト。
- トレイトオブジェクトは下記を保持する構造体
  - インスタンスのポインタ
  - インスタンスのメソッドへの関数ポインタのリスト

### サイズの合わないデータの処理
トレイトは元の構造体を難読化するため元のサイズも難読化されるらしい
&nbsp;
**難読化**
- 元の構造体を抽象化していること(コンパイル時には確定していないみたいな)

でもRustの構造体ではフィールドに格納する時にサイズがわかっていなければならない、しかし、トレイトオブジェクトは大きさがコンパイル時には確定していない

そのため、下記の二つの方法でサイズが合わないデータの処理を行う
&nbsp;
- **generics**
   - パラメータ化された型を使用して、既知の型、つまり既知のサイズの構造体/関数を効果的に作成する
**静的ディスパッチ**なのでコンパイル時に確定している型のサイズを作成する
Rust
```
struct MyStruct<T: NoiseMaker> {
    item: T, // ← Tが具体的な型ならサイズも確定
}
```

&nbsp;
- **indirection**
  - ヒープ上にインスタンスを置くことで、実際の型のサイズを気にすることなく、単にそのポインタを格納することができるインダイレクトのレベルを得ることができる。
  - サイズが固定であるポインタのメモリに格納してそこから参照する
  - フィールドにトレイトを入れるならこっち

```Rust
struct MyStruct {
    item: Box<dyn NoiseMaker>, // ← ポインタ(Box)のサイズは固定
}
```

### ジェネリック関数

**ジェネリクス**
- 簡単にいうと型の抽象化
- 下記ではパラメータのTは、具体的な型ではなく`std::fmt::Display`が実装されている型なら何でもok
  - これによってコードに柔軟性を持たせる 
```Rust
fn print_value<T: std::fmt::Display>(x: T) {
    println!("{}", x);
}
```

Rustのジェネリクスは、トレイトと密接に連携しているらしい。
- パラメータ化された型 T を記述するとき、引数に実装しなければならない必須のトレイトを列挙することで、引数として使用できる型を制限することができる。

つまり
- 下記ではジェネリクス`generic_make_noise`の引数にはトレイト`NoiseMaker`を実装している型しかNG
```Rust
fn generic_make_noise<T>(creature: &T)
where
    T: NoiseMaker,
{
    // we know the real type at compile-time
    creature.make_noise();
}
```

ジェネリクスは型を渡して定義するので、静的ディスパッチでコンパイル時にサイズが確定し最適化できるという利点がある
```Rust
print_item(123);     // i32版が生成される
print_item("hello"); // &str版が生成される
```
**省略記法**

```Rust
fn my_function(foo: impl Foo) {
    ...
}
```
上記の記法は下記のものと同等です。

```Rust
fn my_function<T>(foo: T)
where
    T:Foo
{
    ...
}
```

### ボックス
`Box` は、データをスタックからヒープに移動させるためのデータ構造
- `Box` はスマートポインタと呼ばれる構造体で、ヒープ上のデータへのポインタを保持する。
- `Box` はサイズが既知の構造体であるため（ポインタを保持しているだけなので）、 フィールドのサイズを知っていなければならない構造体の中で、何かの参照を格納する方法としてよく使われる。

動的ディスパッチの時に実は触れていた
```Rust
struct MyStruct {
    item: Box<dyn NoiseMaker>, // ← ポインタ(Box)のサイズは固定
}
```

 この章で`Box` を使用してスマートポインタを触れた。
 次の章では、スマートポインタが他の特殊なメモリの状況でどのように役立つかについて触れるらしい。