---
title: "5章"
free: false
---

## データの所有権と借用

- Rustでは型のインスタンスを作成して変数にバインドするとメモリリソースが作成される。バインドされた変数はリソースの所有者と呼ばれる
  - つまり、メモリリソースが変数に結びついているよってこと
&nbsp;
**下記のような事象を防ぐために所有権という概念が存在する。**
- リソースの意図しない変更
- リソースの解放漏れ
- リソースを誤って複数回解放
- 解放されたリソースの利用
- 他でリソースを読み込んでいる最中にリソースへの書き込みが行われた場合に発生するデータ競合
- コンパイラが保証できない部分の明確化

&nbsp;
**(ガベージコレクション)**
- コンピュータープログラムの実行中に不要になったメモリ領域を自動的に解放する機能
&nbsp;

**Rustはガベージコレクションがない**
- そのためスコープの終わりにリソースをドロップ（解放）する
&nbsp;
**これによって**
- 解放ずみメモリを参照するバグを防げる
- 二重にリソースを解放することがない
- 明示的に所有権を制御できるので意図しないリークが起こりにくい
  - 基本はその変数のメモリリソースを使えるのは同時に一人だけって考えとくといいのか？

### 所有権の移動
所有者が関数の実引数として渡されると所有権は関数の仮引数に移動する
&nbsp;
下記のコード例だと`println!`でコンパイルエラーが起こる
`foo`の所有権が`do_something`に移動し、そのスコープ内でリソースが解放されているため
```Rust
struct Foo {
    x: i32,
}

fn do_something(f: Foo) {
    println!("{}", f.x);
    // f はここでドロップ
}

fn main() {
    let foo = Foo { x: 42 };
    // foo の所有権は do_something に移動
    do_something(foo);
    // foo は使えなくなる
    println!("{}", foo.x);
}
```

所有権を返すこともできる
&nbsp;
**ユースケース**
  - 関数を呼び出して値を作って返すとき
  - 引数で受け取った値を関数で操作して返す時
  - 可変で扱いたいけど参照はしたくない時（そんな時がいつ来るのかは知らん）
```Rust
struct Foo {
    x: i32,
}

fn do_something() -> Foo {
    Foo { x: 42 }
    // 所有権は外に移動
}

fn main() {
    let foo = do_something();
    // foo は所有者になる
    // 関数のスコープの終端により、foo はドロップ
}
```

### 所有権の借用
所有権は移動させずに値を参照して使うことができる。借りているだけなので値を使っているけど所有権は移動しないってこと

`＆`演算子を使えばリソースのアクセスを参照によって借用できる
&nbsp;
**ユースケース**
  - 所有権を渡さずに値を使いたい時
  - 値を共有して複数の場所で使いたい時
  - メモリを節約したい時（配列とか構造体が大きい時）
&nbsp;
```Rust
fn print_foo(f: &Foo) {
    println!("{}", f.x);
}

fn main() {
    let foo = Foo { x: 42 };
    print_foo(&foo); // 所有権を渡さない
    println!("{}", foo.x); // foo まだ使える
}
```

`&mut`演算子を使えば、リソースへの変更可能なアクセスを借用できる
  - 可変な借用をしている間は元のリソースの持ち主はリソースを移動、変更することができない(貸せる状態で貸しているので)
  - 通常の借用は見せるだけだけど、可変の借用は完全に貸す感じ
 ```Rust
struct Foo {
    x: i32,
}

fn do_something(f: Foo) {
    println!("{}", f.x);
    // f はここでドロップ
}

fn main() {
    let mut foo = Foo { x: 42 };
    let f = &mut foo;

    // 失敗: do_something(foo) はここでエラー
    // foo は可変に借用されており移動できないため

    // 失敗: foo.x = 13; はここでエラー
    // foo は可変に借用されている間は変更できないため

    f.x = 13;
    // f はここから先では使用されないため、ここでドロップ
    
    println!("{}", foo.x);
    
    // 可変な借用はドロップされているため変更可能
    foo.x = 7;
    
    // foo の所有権を関数に移動
    do_something(foo);
}
```
&nbsp;
### 参照外し

`&mut`で借りている間は`*`演算子で参照を外すことで、所有者の値を設定できる
`*`演算子で所有者の値をコピーできる

```Rust
fn main() {
    let mut foo = 42;
    let f = &mut foo;
    let bar = *f; // 所有者の値を取得
    *f = 13;      // 参照の所有者の値を設定
    // 42
    println!("{}", bar);
    // 13
    println!("{}", foo);
}
```
&nbsp;
**ユースケース**
- 変更前の値を取り出して使いたい時
- 借用しながら値を更新したい時
- 構造体のフィールドに関して部分的に値を扱いたい時
  - Rustはメモリ安全性をコンパイル時に100%保証したいという思想がある
  - 構造体のフィールドはメモリ上では隣り合っている可能性があるため、その一部だけ安全に借りているって保証できないから複数のフィールドを同時に借りることができないらしい
    - だから参照を外して所有者の持つ値を変える必要がある
```Rust
truct Counter {
    value: i32,
    label: String,
}

fn main() {
    let mut c = Counter {
        value: 10,
        label: "Main Counter".to_string(),
    };

    // `value` だけを変更
    {
        let v = &mut c.value;
        *v += 5;
    }

    // `label` を表示（借用が解除されたからOK）
    println!("{}: {}", c.label, c.value);
}

```
&nbsp;
### 借用したデータの受け渡し
借用のルールをおさらい
- 可変な参照が一つか不変な参照が複数かのどちらかが許可される
- 参照は所有者よりも長く存在してはいけない(所有者いないなら貸せないよねって)
- データ競合（同時にデータの書き込みが行われて同期取れなくなるやつ）や存在しないデータへの参照を防ぐため
&nbsp;
### 参照の参照(???)
参照の一部を参照できる

可変な借用をバインドしたxがそのスコープ内で使われていないからドロップ、不変な借用が作れる
```Rust
struct Foo {
    x: i32,
}

fn do_something(a: &Foo) -> &i32 {
    return &a.x;
}

fn main() {
    let mut foo = Foo { x: 42 };
    let x = &mut foo.x;
    *x = 13;
    // x はここでドロップされるため、不変な参照が作成可能
    let y = do_something(&foo);
    println!("{}", y);
    // y はここでドロップ
    // foo はここでドロップ
}
```
&nbsp;
逆のパターンで不変な借用から可変な借用は同一のスコープ内ではできない、 rustは下記のようにスコープを制御構文なしで作れるから所有権の移動とか借用を範囲制限できるらしい
```Rust
struct Foo {
    x: i32,
}

fn main() {
    let mut foo = Foo { x: 42 };

    // 不変な借用
    let r1 = &foo.x;
    println!("{}", r1);  // 42

    // r1 のスコープを明示的に制限して、可変借用を許可
    {
        let r2 = &mut foo.x;  // 可変借用
        *r2 = 99;  // foo.x を 99 に変更
    }

    println!("{}", foo.x);  // 99
}
 ```
&nbsp;
### ライフタイムの明示
- Rustではコンパイラが全ての変数のライフタイムを管理しており、参照がどの章勇者よりも長く存在しないことを検証しようとしている。

-  ライフタイム指定子を `' a`,`' b`,`' `c`のように用いることで、どの引数と戻り値がライフタイムを共有しているかどうかを明示的に指定できる

コンパイラがライフタイムを自動的に推論できない時に明示的に指定してあげることで、理想の挙動をさせるために使うっぽい、今すぐは使わなそう。
&nbsp;
### staticなライフタイム
`static`で変数を宣言すると、コンパイル時に作成され、プログラムの開始から終了まで存在するメモリリソースとなる。
プログラムの終了までドロップしない
`static`変数が参照する値は`static`である必要がある。参照している所有者が先にドロップしてしまうことを防ぐため

- `static`無変数を途中で変更することは危険、誰でもアクセスできるグローバル変数の様な概念なので