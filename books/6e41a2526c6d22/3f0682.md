---
title: "8章"
free: false
---

## Smart Pointers

### Smart Pointers
- 最も低レベルのメモリとやりとりするためのデータ構造
  - 後述するRaw Pointerとは**メモリの所有権や寿命の管理、アクセス方法のルールを持ったオブジェクト**という点で異なる

参照は基本的に、メモリ上のあるバイトの開始位置を示す数値にすぎない
- その唯一の目的は、特定の型のデータがどこに存在するかという概念を表すこと
- 参照が単なる数値と異なるのは、Rustが参照の有効期間が参照先よりも長くないことを検証すること
  - 参照先よりも参照が先にドロップしてリソースを解放するよねってこと 

### Raw Pointers(生ポインタ?)
参照はRaw Poinerと呼ばれる、より原始的な型に変換することができる。
- 数値のように、ほとんど制限なくコピーや移動が可能。
- Rustは、ポインタが指すメモリ位置の正当性を保証しない。

2種類のRaw Pointerが存在する
&nbsp;
- ***const T**
  - T型への不変のRawPointer

- ***mut T**
  - T型への可変のRaw Pointer


下記を実行すると結果は`Data is here 140721581958572`となる
- 参照をポインタに変換できていることがわかる  
```Rust
fn main() {
    let a = 42;
    let memory_location = &a as *const i32 as usize;
    println!("Data is here {}", memory_location);
}
```
 
**メモリの詳細**
- Rustの参照は、C言語のポインタと使い方がよく似ているが、他の関数に格納したり移動したりする方法について、コンパイル時に多くの制限がある。
- RustのRaw Pointerは、C言語のポインタに似ており、コピーや受け渡しが可能な数値を表し、さらに数値型に変換して数値として変更し、ポインタ演算を行うことができる。

## Dereferencing(逆参照)
参照によって参照されているデータにアクセス/操作することを、**逆参照(dereferencing)**という

Rustにおいて参照は2つの方法でデータへのアクセス/操作に使用される
  - 変数の代入時に参照先のデータへアクセス
  - そのままオブジェクトとして参照先を変数に代入する感じ
```Rust
let x = 5;
let r = &x;
println!("{}", *r);  // *r によって、中身（5）にアクセス
```
  - 参照されたデータのフィールドやメソッドへのアクセス
    - つまり Rust では r.x は (*r).x と同じ意味になります。
    - 参照先のオブジェクトのフィールドやメソッドにアクセスする感じ
      
```Rust
struct Point {
    x: i32,
}

let p = Point { x: 42 };
let r = &p;

println!("{}", r.x);          // 自動的に *r.x → (*r).x にしてくれる

```
Rustには、これを可能にする強力な演算子がいくつかある。

### `*`演算子
`*`演算子は参照を明示的に逆参照にする演算子

実務では基本しないが3重に参照してそれを二重に逆参照したりとかもできるらしい
```Rust
let a: i32 = 42;
let ref_ref_ref_a: &&&i32 = &&&a;
let ref_a: &i32 = **ref_ref_ref_a;
let b: i32 = *ref_a;
```

### `.`演算子
`.`演算子は参照先のフィールドやメソッドにアクセスするために使用される
- .演算子が自動的に一連の参照を解除するため`println!("{}", (***ref_ref_ref_f).value);`の様に書く必要がない

```Rust
let f = Foo { value: 42 };
let ref_ref_ref_f = &&&f;
println!("{}", ref_ref_ref_f.value);
```

### Smart Pointers
Rustでは、`&`演算子を使って既存の型付きデータへの参照を作成する機能に加えて、Smart Pointerと呼ばれる参照のような構造体を作成する機能がある。

- 参照とは別の型にアクセスできるようにするための型みたいなイメージ？。
- スマートポインタは、プログラマが書いた内部ロジックに基づいて動作するという点で、通常の参照とは動作が異なる
- 一般的に、スマートポインターはDeref、DerefMut、Dropの各特性を実装し、構造体が*や.演算子で再参照されたときに起こるべきロジックを指定する。

### Unsafe Code
Rustは安全なメモリ管理を大きな特徴としており、通常のコードではコンパイラが所有権、ライフタイム、借用ルールをチェックしてくれる。
&nbsp;
しかし、以下のようなケースはコンパイラが正しさを保証できない
&nbsp;
- Raw Pointer（`*const T`や`*mut T`）の逆参照
- アセンブリコードとの連携
- 手動のメモリ確保／解放（`alloc`／`dealloc`）
- グローバル変数のミューテーション など
  &nbsp;
 この様な**コンパイラの保証外の操作** を行うには `unsafe` ブロックが必要である

#### 例えば

a は4つの`u8`値（バイト）からなる配列
```Rust
fn main() {
    let a: [u8; 4] = [86, 14, 73, 64];
```

`&a`は`&[u8; 4]`型だが、`*const u8`にキャストするとRaw Pointerになる
さらに`as usize`で メモリアドレスを数値として取得

- 配列 a の先頭アドレス（生ポインタ）を数値で出力してみると結果は下記のようになる、ここまでは普通
  - Data memory location: 140727448895548
 ```Rust
    let pointer_a = &a as *const u8 as usize;

// 結果は Data memory location: 140727448895548
    println!("Data memory location: {}", pointer_a);
```

では、この数値（実際には` [u8; 4]`の先頭アドレス）を`*const f32`に再キャストしてみる
- 「この場所には f32 型が格納されている」と仮定している
&nbsp;
ただし、Rust はこの仮定が正しいかどうかを保証できない
```Rust
    let pointer_b = pointer_a as *const f32;
```

この`pointer_b`を逆参照して`f32`型として読み出そうとしているが、実際は`[u8; 4]`
- 仮にメモリ上の値が f32 として有効だったとしても、それはたまたまうまくいっただけで安全ではない
```Rust
    let b = unsafe {
        *pointer_b
    };
```

この場合には`unsafe`ブロックを使用しないとコンパイルエラーになる
- コンパイラにこのコードはRustの安全保障外の書き方だけど、正しいロジックなので安全ですよと教えてあげるのだ、unsafeブロックを宣言した箇所では開発者が責任を担保する必要がある。
  &nbsp;
- コンパイル時に`unsafe`があると、そのブロック内で安全チェックが一部スキップされるために高速になる
- 実行時にも`unsafe`があると、オーバーヘッド(処理を安全・便利にするために発生する 追加の計算・メモリ・実行時間のコスト)が無いので早い。
&nbsp;
-> しかし、バグは自己責任＆発見困難になる可能性があるトレードオフ

Smart Pointer（`Box`, `Rc`, `RefCell`など）の内部では、このようなRaw Pointer操作やメモリ操作が `unsafe`で行われている。ただし、Smart PointerのパブリックなAPIはすべて安全（`safe`）になるよう設計されている。

**「unsafe を使うのはライブラリの実装者。ライブラリの利用者は safe なままでいられるようにする」**
というのが Rust の設計哲学だかららしい

## Familiar Friends(おなじみの友達)
`Vec<T>`や`String`の様なSmart Pointerについてを考えてみよう。
&nbsp;
**`Vec<T>`**
- Smart Pointerでありバイトのメモリ領域を所有するだけ
  - Rustのコンパイラは、これらのバイトの中に何があるのかを知らない
- `Vec`は、自身が管理するメモリ領域からアイテムを取得することの意味を解釈する
  - それらのバイト内のデータ構造がどこで始まり、どこで終わるかを追跡している
    - その情報を使って、Raw Pointer（低レベルのメモリアドレス）を安全かつ便利な形に変換してくれる

同様に、
**String**もバイトのメモリ領域を追跡し、そこに書き込まれるコンテンツが常に有効な`utf-8`であるようにプログラムで制限し、そのメモリ領域を`&str`型に逆参照する

これらのSmart Pointerはどちらも、Raw PointerをのUnsafeによる逆参照を使用している。
- Rustが高レベルで安全なのは、裏側で`Unsafe`を用いた低レベルの処理が土台となっているおかげ

### Heap Allocated Memory
`Box` は、データをスタックからヒープに移動させるSmart Pointerである
- これを再参照することで、ヒープに割り当てられたデータを元の型と同じように使うことができる

### Failable Main Revisited(再び取り上げる：エラーを返す main 関数)

Rustではエラーの表現方法がたくさんあるが、標準ライブラリにはそれらをまとめて扱える共通のトレイト である`std::error::Error`がある。
- `Box<dyn std::error::Error>`を使えば、エラーをヒープ上に格納し、具象型（具体的な型）を気にせず高レベルで扱える。
  - `Error`トレイトを実装していれば扱えるBoxということ

[以前学んだように](https://tourofrust.com/37_ja.html)、main関数でも`Result`を返すことができる。
- つまり、プログラム全体の入り口であるmain関数で発生しうる多くのエラーを 1 つの共通の型で返せるようになるのだ

```Rust
impl Pie {
    fn eat(&self) -> Result<(), Box<dyn Error>> {
        Err(Box::new(NotFreshError))
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let heap_pie = Box::new(Pie);
    heap_pie.eat()?;
    Ok(())
}
```

### Referencing Counting (参照カウント)

**Rc**
- データをスタックからヒープに移動させるSmart Pointer
- 複数の所有者がそのデータを共有できるようにする
- 所有者（`Rc`）が増えるたびに 参照カウントが増加し、所有者が減るとカウントが減る
- 最後の所有者(`Rc`)が削除されたときだけ、ヒープ上のデータは解放される。

```Rust
// Rcを使うためにインポート
use std::rc::Rc;

struct Pie;

impl Pie {
    fn eat(&self) {
        println!("tastes better on the heap!")
    }
}

fn main() {
// ヒープ上に置かれた Pie を1つ作成）
    let heap_pie = Rc::new(Pie);

// Rc::clone() によって、新しい所有者（参照）を作る
// これは「コピー」ではなく「参照カウントを増やすだけ」。データ自体は1つ。
    let heap_pie2 = heap_pie.clone();
    let heap_pie3 = heap_pie2.clone();

    heap_pie3.eat();
    heap_pie2.eat();
    heap_pie.eat();

    // 関数終了時に heap_pie, heap_pie2, heap_pie3 がスコープから外れ、
    // 最後の参照が削除されることで、ヒープ上の Pie は自動的に解放される
}

```

## Sharing Access

**RefCell** 
- Smart Pointerと一緒に使われることが多い**内部可変性（interior mutability）**を提供するデータ構造
  - 中に保持されたデータに対して 「不変（`&T`）」または「可変（`&mut T`）」の参照を動的に貸し出すことができるコンテナというイメージ
  - `RefCell`を使えば`mut`でなくても内部可変性があるため可変操作が可能
&nbsp;

通常のRust のルールでは、**コンパイル時**に以下のように制限される
- 不変な参照（`&T`）は何個でもOK
- 可変な参照（`&mut T`）は一度に1つだけ
- 両者を同時に持つことは 禁止

&nbsp;
しかし `RefCell<T>` はこの制約を**実行時**にチェックする
- 実行時に借用ルールを違反すると`panic!`を起こしてプログラムがクラッシュする

&nbsp;
下記を実行すると最終的なプリント結果は6
`RefCell`で包むことで可変アクセスが必要な変数`pie`を`mut`なしで扱える様になっている
- 下記のメソッドを使うことでコンパイル時になく動的に所有権を与え、実行時に借用ルールのチェックを行うのだ
  - `.borrow()`：不変参照を動的に借りる
  - `.borrow_mut()`：可変参照を動的に借りる

```Rust
use std::cell::RefCell;

struct Pie {
    slices: u8
}

impl Pie {
    fn eat(&mut self) {
        println!("tastes better on the heap!");
        self.slices -= 1;
    }
}

fn main() {
    let pie_cell = RefCell::new(Pie{slices:8});
    
    {
        let mut mut_ref_pie = pie_cell.borrow_mut();
        mut_ref_pie.eat();
        mut_ref_pie.eat();
    }
    
     let ref_pie = pie_cell.borrow();
     println!("{} slices left",ref_pie.slices);
}
```

## Sharing Across Threads (スレッド間でのアクセスの共有)
**Mutex** 
- `Mutex<T>`は内部の値にアクセスする前に「ロック」を必要とする箱（コンテナ）
- データを包み込み、そのデータへの可変／不変な参照を安全に借りることができる
- OSの力でスレッドごとにアクセスを制限して借用ルールを守るらしい
&nbsp;
複数のスレッドから同じデータに安全にアクセスするためにために用いる
- Rust では、**マルチスレッド安全性（thread safety）**をコンパイル時に強く保証ため、`Mutex<T>` のような同期ツールが必要不可欠らしい


**Arc**
-`Rc` に似ているが、参照カウントをスレッド安全に管理する点が異なる。
  - 複数のスレッドで`Mutex<T>`を共有する場合に、`Arc<Mutex<T>>`の形で使われる。
- `Rc<T>`はシングルスレッド専用だが、`Arc<T>`は マルチスレッドで使える

`Arc<Mutex<T>>`によって、「複数のスレッドが一つのデータを所有し、同時には触らせない」設計が可能

- Mutexに包んだ状態でPie構造体に対して`.lock()`でロックし、中へのアクセス権を獲得している
  - 失敗する可能性があるため`.unwrap()`などでエラーハンドリングは必要 
```Rust
use std::sync::Mutex;

struct Pie;

impl Pie {
    fn eat(&self) {
        println!("only I eat the pie right now!");
    }
}

fn main() {
    let mutex_pie = Mutex::new(Pie);
    let ref_pie = mutex_pie.lock().unwrap();
    ref_pie.eat();
}

```

## Combining Smart Pointers

Rust では複数のSmart Pointerを組み合わせて使うことで、強力なメモリ管理ができる。
- 代表的な組み合わせ例は以下の3つ
&nbsp;
**Rc<Vec<Foo>>**
- 不変なデータ（`Vec<Foo>`）を複数のSmart Pointerで安全に共有
- 読み取り専用のデータを、複数の場所からアクセスしたい時など
 &nbsp;
**Rc<RefCell<Foo>>**
- 構造体`Foo`を複数の場所から可変／不変どちらでも借用可能 にする
- 複数のオブジェクトが同じデータを操作したいけど、変更もしたい時など
 - `Rc<T> `によって複数所有
 - `RefCell<T> `によって実行時に借用ルールをチェック
&nbsp;
 **Arc<Mutex<Foo>>**
- `Foo`をスレッド間で共有して、同時に使わないようにロック付きで管理
- マルチスレッド環境でデータ共有しながら安全に操作したい時など
  - `Arc<T>`はスレッド対応の共有スマートポインタ
  - `Mutex<T>`はスレッド安全なロックで保護された可変借用
&nbsp;
**Interior Mutability パターン**
- 一見`&T`などの不変参照のように見える型が、内部的に値を書き換えることを許すデザインパターン。
   - たとえば、`RefCell<T>` は「不変に見せておいて実行時に変更を許す」ことで、Rust の安全性を維持したまま柔軟性を持たせている
- このように「外側は不変、中は可変」という仕組みが**interior mutability（内部可変性）**


## まとめ
- Smart Pointerは、Rustにおける慣用表現（イディオム）であり、よくあるメモリ使用パターンを自分で毎回実装しなくてもよくするためのツール
- 第9章では、1ファイルに収まるような小さなコードから飛び出して、本格的な構造化へと進むらしい