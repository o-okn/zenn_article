---
title: "3章"
free: false
---

## 構造体

- struct
  - フィールドに`struct`を持たせることも可能（`string`とか）
```Rust
struct SeaCreature {
    animal_type: String,
    name: String,
    arms: i32,
    legs: i32,
    weapon: String,
}
```

(**関数とメソッドの違い**)
- メソッドは型に紐づく、関数はそうでない

### メソッドの定義

 - **staticメソッド**
型そのものに紐づき、`::`演算子で呼び出す
 - **instanceメソッド**
 インスタンスに紐づき、`.`演算子で呼び出す

```Rust
fn main() {
    // スタティックメソッドでStringインスタンスを作成する。
    let s = String::from("Hello world!");
    // インスタンスを使ってメソッド呼び出す。
    println!("{} is {} characters long.", s, s.len());
}
```

## メモリ
Rustのプログラムでは３種類のメモリ空間を持っている

- **データメモリ**
固定長もしくは staticなデータ
プログラム内の文字列とか
メモリ上の位置はすでに知られていてかつ固定であるため非常に早く扱うことができる

- **スタックメモリ**
関数内で宣言された変数、関数が呼び出されている間はメモリ上の位置は変更されないため
スタックメモリに関しても非常に早くデータにアクセスできる

- **ヒープメモリ**
プログラムの実行時に作られるデータ
このメモリにあるデータは追加、移動、削除、サイズの調整などが許されている。
動的であるため遅いと思われがちだが、このデータによってメモリの柔軟性を生み出すことができる

- **アロケーション**
データをヒープメモリに入れること

- **ディアロケーション**
データをヒープメモリから削除すること

**例）構造体**
- 構造体をインスタンス化するとフィールドに入るデータを隣り合う様にメモリ上に作成する
- "crab"とかのStringは文字列であり読み取り可能なのでデータメモリ
- 関数の呼び出し箇所である`String::from`では構造体`String`を作成し、この構造体とSeaCreatureのフィールドを隣り合う形でスタックに入れる
- ヒープに変更可能なメモリを用意してそこにデータを入れる
その参照アドレスをヒープに用意、それをスタックにあるStringに保存
- インスタンスであるSarahはプログラムの中では固定な位置にあるのでスタックに入る。
  - `mut`ついてないし
```Rust
struct SeaCreature {
    animal_type: String,
    name: String,
    arms: i32,
    legs: i32,
    weapon: String,
}

fn main() {
    // SeaCreatureのデータはスタックに入ります。
    let ferris = SeaCreature {
        // String構造体もスタックに入りますが、
        // ヒープに入るデータの参照アドレスが一つ入ります。
        animal_type: String::from("crab"),
        name: String::from("Ferris"),
        arms: 2,
        legs: 4,
        weapon: String::from("claw"),
    };

    let sarah = SeaCreature {
        animal_type: String::from("octopus"),
        name: String::from("Sarah"),
        arms: 8,
        legs: 0,
        weapon: String::from("none"),
    };
    
    println!(
        "{} is a {}. They have {} arms, {} legs, and a {} weapon",
        ferris.name, ferris.animal_type, ferris.arms, ferris.legs, ferris.weapon
    );
    println!(
        "{} is a {}. They have {} arms, and {} legs. They have no weapon..",
        sarah.name, sarah.animal_type, sarah.arms, sarah.legs
    );
}
```

 **その他のインスタンスの立て方**
- タプルの様な構造体も利用できる
`struct Location(i32, i32);`
- フィールドを持たない構造体、これはあんま使わないらしい
`struct Marker;`

## 列挙型
enum的な

```Rust
#![allow(dead_code)] // この行でコンパイラのwaringsメッセージを止めます。
enum Species {
    Crab,
    Octopus,
    Fish,
    Clam
}

struct SeaCreature {
    species: Species,
    name: String,
    arms: i32,
    legs: i32,
    weapon: String,
}

fn main() {
    let ferris = SeaCreature {
        species: Species::Crab,
        name: String::from("Ferris"),
        arms: 2,
        legs: 4,
        weapon: String::from("claw"),
    };

    match ferris.species {
        Species::Crab => println!("{} is a crab",ferris.name),
        Species::Octopus => println!("{} is a octopus",ferris.name),
        Species::Fish => println!("{} is a fish",ferris.name),
        Species::Clam => println!("{} is a clam",ferris.name),
    }
}
```

- 一個もしくは複数の型データを持つことができる
- メモリサイズはそれが持つ最大要素のサイズと等しくなるため、代入可能な値なら同じサイズのメモリ空間を利用可能にしている

```Rust
enum PoisonType { Acidic, Painful, Lethal }
enum Size { Big, Small }
enum Weapon {
    Claw(i32, Size),
    Poison(PoisonType),
    None
}
```