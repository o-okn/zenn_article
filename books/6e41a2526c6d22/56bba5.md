---
title: "4章"
free: false
---

## ジェネリック型

`struct`や`enum`を部分的に定義することを可能にする
 -  つまり、コンパイル時にコードの使用状況に基づいて定義する
 -  その際、コードからRustが型を推論してくれるが`::<T>`演算子を使うと補助できる

Rustでは安全性のために`null`がない
よくあるエラーのほとんどはぬるぽなので、、

ジェネリック型で部分的に定義することに`None`を組み合わせることであたいがないことを表現できる
```Rust
enum Item {
    Inventory(String),
    // None は項目がないことを表す
    None,
}

struct BagOfHolding {
    item: Item,
}

let bag = BagOfHolding {
    item: Item::None,
};
```

`enum`が下記の様に定義されてたら値がないことを表すことはできない
```Rust
enum Item {
    Inventory(String),
}
```

もっと自然な書き方
調べたら器側に`option`を持たせる方が慣習的らしい
```Rust
enum Item {
    Inventory(String),
}

struct BagOfHolding {
    item: Option<Item>,
}

let bag_with_item = BagOfHolding {
    item: Some(Item::Inventory("Potion".to_string())),
};

let empty_bag = BagOfHolding {
    item: None,
};
```

## Result

- Rustに用意されているジェネリックな列挙型
- こいつを使ってエラーハンドリングを行うのが慣用的

```Rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

```Rust
fn do_something_that_might_fail(i:i32) -> Result<f32,String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("正しい値ではありません"))
    }
}

fn main() {
    let result = do_something_that_might_fail(12);

    // match は Result をエレガントに分解して、
    // すべてのケースが処理されることを保証できます！
    match result {
        Ok(v) => println!("発見 {}", v),
        Err(e) => println!("Error: {}",e),
    }
}

```

## エラーハンドリングについて
**?演算子**
`Result`と`match`を用いたエラーハンドリングを省略して書くことが可能

 ```Rust
 do_something_that_might_fail()?
```

```Rust
match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```

`Option`とResultには`unwrap`という関数があり、ちょっとしたコード書くなら簡潔に書ける
でも基本的には`match`を使うべき

`unwrap`は失敗した時に`panic`を起こしてしまうので、実行時にエラーを引き起こす（エラーハンドリングできない）

`match`は全てのケースを網羅できる
失敗時の挙動を自分で制御できる
可読性が高いので

```Rust
my_result.unwrap()
```

```Rust
match my_result {
    Ok(v) => v,
    Err(e) => panic!("Rust によって生成されたエラーメッセージ！"),
}
```

## ベクタ型
構造体`Vec`で表される可変サイズのリスト
`vec!`を用いて簡単にリストを作成できる

`iter()`を用いてベクタからイテレータを生成することでベクタを簡単に`for`ループに入れることができる

```Rust
fn main() {
    // 型を明示的に指定
    let mut i32_vec = Vec::<i32>::new(); // turbofish <3
    i32_vec.push(1);
    i32_vec.push(2);
    i32_vec.push(3);

    // もっと賢く、型を自動的に推論
    let mut float_vec = Vec::new();
    float_vec.push(1.3);
    float_vec.push(2.3);
    float_vec.push(3.4);

    // きれいなマクロ！
    let string_vec = vec![String::from("Hello"), String::from("World")];

    for word in string_vec.iter() {
        println!("{}", word);
    }
}

```

構造体だけど、内部的にはヒープ上の固定リストへの参照を含んでいる
容量はデフォルトで定まり、容量よりも多くの項目が追加された場合に、ヒープ上により大きな容量の固定リストを生成してデータを再割り当てするらしい